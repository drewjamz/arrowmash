**Game Overview**

Our game is Arrow Mash, a controller version of Dance Dance Revolution where two players compete in a rhythm-like style. Arrows slowly fall vertically from the top of the screen, eventually reaching the “active zone”. In this zone the players must press the right arrow pattern on their respective controller. There are 4 potential buttons that players can press, which each correspond to one of the four directional arrows on the controller. Only one button ever needs to be pressed at a time by a player, and the two players should be able to press a button at the same time. Each time a player misses an arrow or presses at the wrong time, they lose a colored heart (a blue heart for player 1, a red heart for player 2). The first player to miss three times runs out of hearts and “loses.” 

For the visual components in this image, you can see two rows of three hearts, a set of four empty arrows for each player, and colored arrows falling towards the empty arrows. The hearts are bound to each player’s lives, with the red ones representing the left player’s and the blue ones representing the player on the right. The empty arrows are an indicator of the general area where the colored arrows should fall before a player should press the relevant button. Their shapes also indicate which arrow falls in that column. The colored arrows are generated with a random direction on a set timer, start at the top of the screen, and fall down towards the empty arrow indicators. 

**Technical Overview**

Our game interacts with a monitor through the VGA adapter, takes in user input through two NES controllers, uses the Game component for game logic, and the Mypattern component for the logic of displaying items on the screen. The high-level overview above shows the components of top.vhd as well as the physical components top interfaces with on a simplified level. The Pllinst creates the clock for the VGA, which we also chose to use as our global clock for pretty much all the components. The controllers send button information to Game through out_data and Game determines whether a life should be lost and to erase the arrow. Game also interfaces with the randomizer to decide which arrow to currently spawn (and which one is possible spawn based on the ones already on the screen), then sends it to Mypattern, which sends it to VGA, which ultimately displays it on the screen. Game also holds the counter to move arrows down the screen.

**Technical Description**
Components:
  1. NES Controllers
  The NES controllers run along a slightly slowed down version of the master clock (about have the frequency). This enables data to be read in by the FPGA efficiently.
  Two NES controller modules were instantiated, one for each player. We would take the 8 bit data output from each controller and implement it in the game logic. The one hot encodings from the controller were used to check if a     player had hit an arrow at the correct time or not. By correctly mapping each respective arrow button, the program checks if a player has pressed the corresponding arrow in the active zone.
  
 
  2. VGA and Pattern_gen
  The VGA module controls the timing for the VGA signal, producing sync signals for the monitor and signals for the pattern_gen module to tell it what pixel to produce an RGB value for.
  The pattern_gen module has to take in a pixel position on screen, and all of the information from the gameplay that needs to be represented on screen and generate the RGB value for that pixel. The game displays hearts that are empty or full to show the player’s remaining lives, blank arrows at the bottom of the screen to show where the button needs to be pressed, as well as up to 8 colored arrows that gradually move down on the screen. We have implemented every object on screen as a 16x16 ROM, scaled up to 32x32 on screen, that begins displaying by its top left corner at any pixel on the screen.
   The pattern_gen module receives from the gameplay:
  8 bit vector to enable and disable arrows, unused.
  8 long array holding the type for each arrow, using 1-hot encoding for up, down, left and right, and 0000 to disable the arrow
  8 long array holding the y-position on screen for each arrow.
   Pattern_gen instantiates a helper for each sprite that can appear on screen, which takes in the pixel position of that sprite and the pixel currently being displayed, and it determines whether that sprite is currently being displayed, and if it is, what pixel of the sprite being displayed. Slightly different versions of the helper are used for different types of objects on screen, for example the hearts to show lives are always on screen, but arrows can be turned on and off. The arrows that move down the screen have a constant x-position based on their type, and need to take in a y-position, while the hearts have a fixed position.
  From the helpers, the pattern_gen module can know which (if any) object it should be displaying, and which pixel of that object’s texture is being displayed. The pattern_gen then sends the pixel and type to the correct arrow/heart selector, to get an RGB value, which it outputs to the screen.
  
  3. ROM/ROM Script and Selectors
  We wrote a python script called 128or16_rom_script.py that reads through each pixel of a 16x16 or 128x128 pixel image and turns it into a .vhd ROM file. Each of the hearts, arrows, blank versions of those, and unimplemented start and end game screens were first drawn as sprites and after, individual ROMs were created using this script. The script allowed us to easily change the file path to the file, the name of the entity being created, and the name of the output file. We also made it so that you specified whether the address was 8 bits or 14 bits, corresponding to a 16x16 or 128x128 pixel image, respectively. The script file automatically detected and threw errors if it could not find the file or if the file did not match what it was expecting.
   The way the ROMS are written is each ROM has an “addr” address in and “data_out” rgb value out. The address of each pixel is the number of bits described earlier, where the first half of the bits corresponds to the row number (of that pixel)  in binary and the second half corresponds to the column number in binary. This is done so that the address is not just an arbitrary random binary number and can hold some sort of information, whether it is used or not. Data_out is a 3-bit rgb value, each bit corresponding to red, green, and blue, for a possibility of 8 colors.
  
  4. Game
  i) Arrows
  Arrows in our game are stored as three arrays with 8 elements each. Each index in the three arrays correspond to an arrow, with the first four being player 1’s arrows and the remaining four belonging to player 2. The first array says if the arrow is enabled, if it’s currently active on the screen and this one is just an 8-bit vector of logic values. If the value at an index i of this array is ‘1’, it means that index i of the other arrays should refer to the same active arrow. The next array stores eight 4-bit logic vectors. We use one-hot 4-bit logic vectors to store the directions of our arrows with each bit corresponding to a single direction. The last array stores 10 bit unsigned integers. These are the y-coordinates of the corresponding arrows. As for their x-coordinates, they come from the arrow type since as seen in the images of our game running, each type of arrow falls in a set column. 
  For the physics behind our arrows, we use a counter to move arrows downward at a set interval, looping through every arrow and if they are enabled, adding to their y-coordinates. When we check that an arrow reaches the bottom of the screen, we instead reset it, deactivate it, and set up the corresponding player to lose a life (index < 4 would be player 1 and player 2 otherwise). If a player presses the button corresponding to an arrow when its y-coordinate is within a certain range near the bottom of the screen indicated by the blank arrows, that arrow is reset immediately and deactivated instead of continuing on towards the bottom of the screen.
  
  ii) Lives
  We store lives for each player in two-bit unsigned values, which are initially set to 3. Lives are lost when a player either presses a directional button that does not correspond to any arrow within the valid y-coordinate range, or when an arrow reaches the bottom of the screen. To prevent losing multiple lives from a single mistake or accidentally holding down a button too long, we implemented a guard system which is explained in more detail in section B4.

